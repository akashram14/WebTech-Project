'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Returns detailed type as string (instead of just 'object' for arrays etc)
 * @private
 * @param {any} value js value
 * @returns {String} type of value
 * @example
 * typeOf({}); // 'object'
 * typeOf([]); // 'array'
 * typeOf(function() {}); // 'function'
 * typeOf(/a/); // 'regexp'
 * typeOf(new Date()); // 'date'
 * typeOf(null); // 'null'
 * typeOf(undefined); // 'undefined'
 * typeOf('a'); // 'string'
 * typeOf(1); // 'number'
 * typeOf(true); // 'boolean'
 * typeOf(new Map()); // 'map'
 * typeOf(new Set()); // 'map'
 */
function typeOf(value) {
  if (value === null) {
    return 'null';
  }
  if (value !== Object(value)) {
    return typeof value;
  }
  return {}.toString.call(value).slice(8, -1).toLowerCase();
}

/**
 * Checks if input string is empty
 * @param  {String} input text input
 * @return {Boolean} true if no input
 */
function isEmpty(input) {
  if (typeOf(input) !== 'string') {
    return true;
  }
  return !input.length;
}

/**
 * Takes a character and a unicode range. Returns true if the char is in the range.
 * @param  {String}  char  unicode character
 * @param  {Number}  start unicode start range
 * @param  {Number}  end   unicode end range
 * @return {Boolean}
 */
function isCharInRange(char = '', start, end) {
  if (isEmpty(char)) return false;
  const code = char.charCodeAt(0);
  return start <= code && code <= end;
}

const VERSION = '4.0.2';

const TO_KANA_METHODS = {
  HIRAGANA: 'toHiragana',
  KATAKANA: 'toKatakana'
};

const ROMANIZATIONS = {
  HEPBURN: 'hepburn'
};

/**
 * Default config for WanaKana, user passed options will be merged with these
 * @type {DefaultOptions}
 * @name defaultOptions
 * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ã‚ and ã‚‘.
 * @example
 * toHiragana('we', { useObsoleteKana: true })
 * // => 'ã‚‘'
 * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()
 * @example
 * toHiragana('only convert the katakana: ãƒ’ãƒ©ã‚¬ãƒŠ', { passRomaji: true })
 * // => "only convert the katakana: ã²ã‚‰ãŒãª"
 * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()
 * @example
 * toRomaji('ã²ã‚‰ãŒãª ã‚«ã‚¿ã‚«ãƒŠ', { upcaseKatakana: true })
 * // => "hiragana KATAKANA"
 * @property {Boolean|String} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.
 * @property {String} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')
 * @property {Object} [customKanaMapping] - custom map will be merged with default conversion
 * @example
 * toKana('wanakana', { customKanaMapping: { na: 'ã«', ka: 'Bana' }) };
 * // => 'ã‚ã«Banaã«'
 * @property {Object} [customRomajiMapping] - custom map will be merged with default conversion
 * @example
 * toRomaji('ã¤ã˜ãã‚Š', { customRomajiMapping: { ã˜: 'zi', ã¤: 'tu', ã‚Š: 'li' }) };
 * // => 'tuzigili'
 */
const DEFAULT_OPTIONS = {
  useObsoleteKana: false,
  passRomaji: false,
  upcaseKatakana: false,
  ignoreCase: false,
  IMEMode: false,
  romanization: ROMANIZATIONS.HEPBURN
};
const LATIN_UPPERCASE_START = 0x41;
const LATIN_UPPERCASE_END = 0x5a;
const LOWERCASE_ZENKAKU_START = 0xff41;
const LOWERCASE_ZENKAKU_END = 0xff5a;
const UPPERCASE_ZENKAKU_START = 0xff21;
const UPPERCASE_ZENKAKU_END = 0xff3a;
const HIRAGANA_START = 0x3041;
const HIRAGANA_END = 0x3096;
const KATAKANA_START = 0x30a1;
const KATAKANA_END = 0x30fc;
const KANJI_START = 0x4e00;
const KANJI_END = 0x9faf;
const PROLONGED_SOUND_MARK = 0x30fc;
const KANA_SLASH_DOT = 0x30fb;

const ZENKAKU_NUMBERS = [0xff10, 0xff19];
const ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];
const ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];
const ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];
const ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];
const ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];
const ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];
const ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];

const HIRAGANA_CHARS = [0x3040, 0x309f];
const KATAKANA_CHARS = [0x30a0, 0x30ff];
const HANKAKU_KATAKANA = [0xff66, 0xff9f];
const KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];
const KANA_PUNCTUATION = [0xff61, 0xff65];
const CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];
const COMMON_CJK = [0x4e00, 0x9fff];
const RARE_CJK = [0x3400, 0x4dbf];

const KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];

const JA_PUNCTUATION_RANGES = [CJK_SYMBOLS_PUNCTUATION, KANA_PUNCTUATION, KATAKANA_PUNCTUATION, ZENKAKU_PUNCTUATION_1, ZENKAKU_PUNCTUATION_2, ZENKAKU_PUNCTUATION_3, ZENKAKU_PUNCTUATION_4, ZENKAKU_SYMBOLS_CURRENCY];

// All Japanese unicode start and end ranges
// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.
const JAPANESE_RANGES = [...KANA_RANGES, ...JA_PUNCTUATION_RANGES, ZENKAKU_UPPERCASE, ZENKAKU_LOWERCASE, ZENKAKU_NUMBERS, COMMON_CJK, RARE_CJK];

const MODERN_ENGLISH = [0x0000, 0x007f];
const HEPBURN_MACRON_RANGES = [[0x0100, 0x0101], // Ä€ Ä
[0x0112, 0x0113], // Ä’ Ä“
[0x012a, 0x012b], // Äª Ä«
[0x014c, 0x014d], // ÅŒ Å
[0x016a, 0x016b]];
const SMART_QUOTE_RANGES = [[0x2018, 0x2019], // â€˜ â€™
[0x201c, 0x201d]];

const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];

const EN_PUNCTUATION_RANGES = [[0x20, 0x2f], [0x3a, 0x3f], [0x5b, 0x60], [0x7b, 0x7e], ...SMART_QUOTE_RANGES];

/**
 * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharJapanese(char = '') {
  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.â€
 * @param  {String} [input=''] text
 * @param  {Regexp} [allowed] additional test allowed to pass for each char
 * @return {Boolean} true if passes checks
 * @example
 * isJapanese('æ³£ãè™«')
 * // => true
 * isJapanese('ã‚ã‚¢')
 * // => true
 * isJapanese('ï¼’æœˆ') // Zenkaku numbers allowed
 * // => true
 * isJapanese('æ³£ãè™«ã€‚ï¼ã€œï¼„') // Zenkaku/JA punctuation
 * // => true
 * isJapanese('æ³£ãè™«.!~$') // Latin punctuation fails
 * // => false
 * isJapanese('Aæ³£ãè™«')
 * // => false
 * isJapanese('â‰ªå½æ‹¬å¼§â‰«', /[â‰ªâ‰«]/);
 * // => true
 */
function isJapanese(input = '', allowed) {
  const augmented = typeOf(allowed) === 'regexp';
  return isEmpty(input) ? false : [...input].every(char => {
    const isJa = isCharJapanese(char);
    return !augmented ? isJa : isJa || allowed.test(char);
  });
}

/**
 * Easy re-use of merging with default options
 * @param {Object} opts user options
 * @returns user options merged over default options
 */
const mergeWithDefaultOptions = (opts = {}) => Object.assign({}, DEFAULT_OPTIONS, opts);

function applyMapping(string, mapping, convertEnding) {
  const root = mapping;

  function nextSubtree(tree, nextChar) {
    const subtree = tree[nextChar];
    if (subtree === undefined) {
      return undefined;
    }
    // if the next child node does not have a node value, set its node value to the input
    return Object.assign({ '': tree[''] + nextChar }, tree[nextChar]);
  }

  function newChunk(remaining, currentCursor) {
    // start parsing a new chunk
    const firstChar = remaining.charAt(0);

    return parse(Object.assign({ '': firstChar }, root[firstChar]), remaining.slice(1), currentCursor, currentCursor + 1);
  }

  function parse(tree, remaining, lastCursor, currentCursor) {
    if (!remaining) {
      if (convertEnding || Object.keys(tree).length === 1) {
        // nothing more to consume, just commit the last chunk and return it
        // so as to not have an empty element at the end of the result
        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];
      }
      // if we don't want to convert the ending, because there are still possible continuations
      // return null as the final node value
      return [[lastCursor, currentCursor, null]];
    }

    if (Object.keys(tree).length === 1) {
      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));
    }

    const subtree = nextSubtree(tree, remaining.charAt(0));

    if (subtree === undefined) {
      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));
    }
    // continue current branch
    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);
  }

  return newChunk(string, 0);
}

// transform the tree, so that for example hepburnTree['ã‚”']['ã'][''] === 'va'
// or kanaTree['k']['y']['a'][''] === 'ãã‚ƒ'
function transform(tree) {
  return Object.entries(tree).reduce((map, [char, subtree]) => {
    const endOfBranch = typeOf(subtree) === 'string';
    map[char] = endOfBranch ? { '': subtree } : transform(subtree);
    return map;
  }, {});
}

function getSubTreeOf(tree, string) {
  return string.split('').reduce((correctSubTree, char) => {
    if (correctSubTree[char] === undefined) {
      correctSubTree[char] = {};
    }
    return correctSubTree[char];
  }, tree);
}

/**
 * Creates a custom mapping tree, returns a function that accepts a defaultMap which the newly created customMapping will be merged with and returned
 * (customMap) => (defaultMap) => mergedMap
 * @param  {Object} customMap { 'ka' : 'ãª' }
 * @return {Function} (defaultMap) => defaultMergedWithCustomMap
 * @example
 * const sillyMap = createCustomMapping({ 'ã¡ã‚ƒ': 'time', 'èŒ': 'cookie'ã€€});
 * // sillyMap is passed defaultMapping to merge with when called in toRomaji()
 * toRomaji("It's èŒ ã¡ã‚ƒ ã‚ˆ", { customRomajiMapping: sillyMap });
 * // => 'It's cookie time yo';
 */
function createCustomMapping(customMap = {}) {
  const customTree = {};

  if (typeOf(customMap) === 'object') {
    Object.entries(customMap).forEach(([roma, kana]) => {
      let subTree = customTree;
      roma.split('').forEach(char => {
        if (subTree[char] === undefined) {
          subTree[char] = {};
        }
        subTree = subTree[char];
      });
      subTree[''] = kana;
    });
  }

  return function makeMap(map) {
    const mapCopy = JSON.parse(JSON.stringify(map));

    function transformMap(mapSubtree, customSubtree) {
      if (mapSubtree === undefined || typeOf(mapSubtree) === 'string') {
        return customSubtree;
      }
      return Object.entries(customSubtree).reduce((newSubtree, [char, subtree]) => {
        newSubtree[char] = transformMap(mapSubtree[char], subtree);
        return newSubtree;
      }, mapSubtree);
    }

    return transformMap(mapCopy, customTree);
  };
}

// allow consumer to pass either function or object as customMapping
function mergeCustomMapping(map, customMapping) {
  if (!customMapping) {
    return map;
  }
  return typeOf(customMapping) === 'function' ? customMapping(map) : createCustomMapping(customMapping)(map);
}

// NOTE: not exactly kunrei shiki, for example ã¢ã‚ƒ -> dya instead of zya, to avoid name clashing
/* eslint-disable */
// prettier-ignore
const BASIC_KUNREI = {
  a: 'ã‚', i: 'ã„', u: 'ã†', e: 'ãˆ', o: 'ãŠ',
  k: { a: 'ã‹', i: 'ã', u: 'ã', e: 'ã‘', o: 'ã“' },
  s: { a: 'ã•', i: 'ã—', u: 'ã™', e: 'ã›', o: 'ã' },
  t: { a: 'ãŸ', i: 'ã¡', u: 'ã¤', e: 'ã¦', o: 'ã¨' },
  n: { a: 'ãª', i: 'ã«', u: 'ã¬', e: 'ã­', o: 'ã®' },
  h: { a: 'ã¯', i: 'ã²', u: 'ãµ', e: 'ã¸', o: 'ã»' },
  m: { a: 'ã¾', i: 'ã¿', u: 'ã‚€', e: 'ã‚', o: 'ã‚‚' },
  y: { a: 'ã‚„', u: 'ã‚†', o: 'ã‚ˆ' },
  r: { a: 'ã‚‰', i: 'ã‚Š', u: 'ã‚‹', e: 'ã‚Œ', o: 'ã‚' },
  w: { a: 'ã‚', i: 'ã‚', e: 'ã‚‘', o: 'ã‚’' },
  g: { a: 'ãŒ', i: 'ã', u: 'ã', e: 'ã’', o: 'ã”' },
  z: { a: 'ã–', i: 'ã˜', u: 'ãš', e: 'ãœ', o: 'ã' },
  d: { a: 'ã ', i: 'ã¢', u: 'ã¥', e: 'ã§', o: 'ã©' },
  b: { a: 'ã°', i: 'ã³', u: 'ã¶', e: 'ã¹', o: 'ã¼' },
  p: { a: 'ã±', i: 'ã´', u: 'ã·', e: 'ãº', o: 'ã½' },
  v: { a: 'ã‚”ã', i: 'ã‚”ãƒ', u: 'ã‚”', e: 'ã‚”ã‡', o: 'ã‚”ã‰' }
};

const SPECIAL_SYMBOLS = {
  '.': 'ã€‚',
  ',': 'ã€',
  ':': 'ï¼š',
  '/': 'ãƒ»',
  '!': 'ï¼',
  '?': 'ï¼Ÿ',
  '~': 'ã€œ',
  '-': 'ãƒ¼',
  'â€˜': 'ã€Œ',
  'â€™': 'ã€',
  'â€œ': 'ã€',
  'â€': 'ã€',
  '[': 'ï¼»',
  ']': 'ï¼½',
  '(': 'ï¼ˆ',
  ')': 'ï¼‰',
  '{': 'ï½›',
  '}': 'ï½'
};

const CONSONANTS = {
  k: 'ã',
  s: 'ã—',
  t: 'ã¡',
  n: 'ã«',
  h: 'ã²',
  m: 'ã¿',
  r: 'ã‚Š',
  g: 'ã',
  z: 'ã˜',
  d: 'ã¢',
  b: 'ã³',
  p: 'ã´',
  v: 'ã‚”',
  q: 'ã',
  f: 'ãµ'
};
const SMALL_Y = { ya: 'ã‚ƒ', yi: 'ãƒ', yu: 'ã‚…', ye: 'ã‡', yo: 'ã‚‡' };
const SMALL_VOWELS = { a: 'ã', i: 'ãƒ', u: 'ã…', e: 'ã‡', o: 'ã‰' };

// typing one should be the same as having typed the other instead
const ALIASES = {
  sh: 'sy', // sha -> sya
  ch: 'ty', // cho -> tyo
  cy: 'ty', // cyo -> tyo
  chy: 'ty', // chyu -> tyu
  shy: 'sy', // shya -> sya
  j: 'zy', // ja -> zya
  jy: 'zy', // jye -> zye

  // exceptions to above rules
  shi: 'si',
  chi: 'ti',
  tsu: 'tu',
  ji: 'zi',
  fu: 'hu'
};

// xtu -> ã£
const SMALL_LETTERS = Object.assign({
  tu: 'ã£',
  wa: 'ã‚',
  ka: 'ãƒµ',
  ke: 'ãƒ¶'
}, SMALL_VOWELS, SMALL_Y);

// don't follow any notable patterns
const SPECIAL_CASES = {
  yi: 'ã„',
  wu: 'ã†',
  ye: 'ã„ã‡',
  wi: 'ã†ãƒ',
  we: 'ã†ã‡',
  kwa: 'ãã',
  whu: 'ã†',
  // because it's not thya for ã¦ã‚ƒ but tha
  // and tha is not ã¦ã, but ã¦ã‚ƒ
  tha: 'ã¦ã‚ƒ',
  thu: 'ã¦ã‚…',
  tho: 'ã¦ã‚‡',
  dha: 'ã§ã‚ƒ',
  dhu: 'ã§ã‚…',
  dho: 'ã§ã‚‡'
};

const AIUEO_CONSTRUCTIONS = {
  wh: 'ã†',
  qw: 'ã',
  q: 'ã',
  gw: 'ã',
  sw: 'ã™',
  ts: 'ã¤',
  th: 'ã¦',
  tw: 'ã¨',
  dh: 'ã§',
  dw: 'ã©',
  fw: 'ãµ',
  f: 'ãµ'
};

/* eslint-enable */
function createRomajiToKanaMap() {
  const kanaTree = transform(BASIC_KUNREI);
  // pseudo partial application
  const subtreeOf = string => getSubTreeOf(kanaTree, string);

  // add tya, sya, etc.
  Object.entries(CONSONANTS).forEach(([consonant, yKana]) => {
    Object.entries(SMALL_Y).forEach(([roma, kana]) => {
      // for example kyo -> ã + ã‚‡
      subtreeOf(consonant + roma)[''] = yKana + kana;
    });
  });

  Object.entries(SPECIAL_SYMBOLS).forEach(([symbol, jsymbol]) => {
    subtreeOf(symbol)[''] = jsymbol;
  });

  // things like ã†ãƒ, ããƒ, etc.
  Object.entries(AIUEO_CONSTRUCTIONS).forEach(([consonant, aiueoKana]) => {
    Object.entries(SMALL_VOWELS).forEach(([vowel, kana]) => {
      const subtree = subtreeOf(consonant + vowel);
      subtree[''] = aiueoKana + kana;
    });
  });

  // different ways to write ã‚“
  ['n', "n'", 'xn'].forEach(nChar => {
    subtreeOf(nChar)[''] = 'ã‚“';
  });

  // c is equivalent to k, but not for chi, cha, etc. that's why we have to make a copy of k
  kanaTree.c = JSON.parse(JSON.stringify(kanaTree.k));

  Object.entries(ALIASES).forEach(([string, alternative]) => {
    const allExceptLast = string.slice(0, string.length - 1);
    const last = string.charAt(string.length - 1);
    const parentTree = subtreeOf(allExceptLast);
    // copy to avoid recursive containment
    parentTree[last] = JSON.parse(JSON.stringify(subtreeOf(alternative)));
  });

  function getAlternatives(string) {
    return [...Object.entries(ALIASES), ...[['c', 'k']]].reduce((list, [alt, roma]) => string.startsWith(roma) ? list.concat(string.replace(roma, alt)) : list, []);
  }

  Object.entries(SMALL_LETTERS).forEach(([kunreiRoma, kana]) => {
    const last = char => char.charAt(char.length - 1);
    const allExceptLast = chars => chars.slice(0, chars.length - 1);
    const xRoma = `x${kunreiRoma}`;
    const xSubtree = subtreeOf(xRoma);
    xSubtree[''] = kana;

    // ltu -> xtu -> ã£
    const parentTree = subtreeOf(`l${allExceptLast(kunreiRoma)}`);
    parentTree[last(kunreiRoma)] = xSubtree;

    // ltsu -> ltu -> ã£
    getAlternatives(kunreiRoma).forEach(altRoma => {
      ['l', 'x'].forEach(prefix => {
        const altParentTree = subtreeOf(prefix + allExceptLast(altRoma));
        altParentTree[last(altRoma)] = subtreeOf(prefix + kunreiRoma);
      });
    });
  });

  Object.entries(SPECIAL_CASES).forEach(([string, kana]) => {
    subtreeOf(string)[''] = kana;
  });

  // add kka, tta, etc.
  function addTsu(tree) {
    return Object.entries(tree).reduce((tsuTree, [key, value]) => {
      if (!key) {
        // we have reached the bottom of this branch
        tsuTree[key] = `ã£${value}`;
      } else {
        // more subtrees
        tsuTree[key] = addTsu(value);
      }
      return tsuTree;
    }, {});
  }
  // have to explicitly name c here, because we made it a copy of k, not a reference
  [...Object.keys(CONSONANTS), 'c', 'y', 'w', 'j'].forEach(consonant => {
    const subtree = kanaTree[consonant];
    subtree[consonant] = addTsu(subtree);
  });
  // nn should not be ã£ã‚“
  delete kanaTree.n.n;
  // solidify the results, so that there there is referential transparency within the tree
  return Object.freeze(JSON.parse(JSON.stringify(kanaTree)));
}

let romajiToKanaMap = null;

function getRomajiToKanaTree() {
  if (romajiToKanaMap == null) {
    romajiToKanaMap = createRomajiToKanaMap();
  }
  return romajiToKanaMap;
}

const USE_OBSOLETE_KANA_MAP = createCustomMapping({ wi: 'ã‚', we: 'ã‚‘' });

function IME_MODE_MAP(map) {
  // in IME mode, we do not want to convert single ns
  const mapCopy = JSON.parse(JSON.stringify(map));
  mapCopy.n.n = { '': 'ã‚“' };
  mapCopy.n[' '] = { '': 'ã‚“' };
  return mapCopy;
}

/**
 * Tests if char is in English unicode uppercase range
 * @param  {String} char
 * @return {Boolean}
 */
function isCharUpperCase(char = '') {
  if (isEmpty(char)) return false;
  return isCharInRange(char, LATIN_UPPERCASE_START, LATIN_UPPERCASE_END);
}

/**
 * Returns true if char is 'ãƒ¼'
 * @param  {String} char to test
 * @return {Boolean}
 */
function isCharLongDash(char = '') {
  if (isEmpty(char)) return false;
  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;
}

/**
 * Tests if char is 'ãƒ»'
 * @param  {String} char
 * @return {Boolean} true if 'ãƒ»'
 */
function isCharSlashDot(char = '') {
  if (isEmpty(char)) return false;
  return char.charCodeAt(0) === KANA_SLASH_DOT;
}

/**
 * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharHiragana(char = '') {
  if (isEmpty(char)) return false;
  if (isCharLongDash(char)) return true;
  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);
}

/**
 * Convert [Hiragana](https://en.wikipedia.org/wiki/Hiragana) to [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * Passes through any non-hiragana chars
 * @private
 * @param  {String} [input=''] text input
 * @return {String} converted text
 * @example
 * hiraganaToKatakana('ã²ã‚‰ãŒãª')
 * // => "ãƒ’ãƒ©ã‚¬ãƒŠ"
 * hiraganaToKatakana('ã²ã‚‰ãŒãª is a type of kana')
 * // => "ãƒ’ãƒ©ã‚¬ãƒŠ is a type of kana"
 */
function hiraganaToKatakana(input = '') {
  const kata = [];
  input.split('').forEach(char => {
    // Short circuit to avoid incorrect codeshift for 'ãƒ¼' and 'ãƒ»'
    if (isCharLongDash(char) || isCharSlashDot(char)) {
      kata.push(char);
    } else if (isCharHiragana(char)) {
      // Shift charcode.
      const code = char.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);
      const kataChar = String.fromCharCode(code);
      kata.push(kataChar);
    } else {
      // Pass non-hiragana chars through
      kata.push(char);
    }
  });
  return kata.join('');
}

/**
 * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Kana](https://en.wikipedia.org/wiki/Kana), lowercase text will result in [Hiragana](https://en.wikipedia.org/wiki/Hiragana) and uppercase text will result in [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} [input=''] text
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toKana('onaji BUTTSUUJI')
 * // => 'ãŠãªã˜ ãƒ–ãƒƒãƒ„ã‚¦ã‚¸'
 * toKana('ONAJI buttsuuji')
 * // => 'ã‚ªãƒŠã‚¸ ã¶ã£ã¤ã†ã˜'
 * toKana('åº§ç¦…â€˜zazenâ€™ã‚¹ã‚¿ã‚¤ãƒ«')
 * // => 'åº§ç¦…ã€Œã–ãœã‚“ã€ã‚¹ã‚¿ã‚¤ãƒ«'
 * toKana('batsuge-mu')
 * // => 'ã°ã¤ã’ãƒ¼ã‚€'
 * toKana('!?.:/,~-â€˜â€™â€œâ€[](){}') // Punctuation conversion
 * // => 'ï¼ï¼Ÿã€‚ï¼šãƒ»ã€ã€œãƒ¼ã€Œã€ã€ã€ï¼»ï¼½ï¼ˆï¼‰ï½›ï½'
 * toKana('we', { useObsoleteKana: true })
 * // => 'ã‚‘'
 * toKana('wanakana', { customKanaMapping: { na: 'ã«', ka: 'bana' } });
 * // => 'ã‚ã«banaã«'
 */
function toKana(input = '', options = {}, map) {
  let config;
  if (!map) {
    config = mergeWithDefaultOptions(options);
    map = createRomajiToKanaMap$1(config);
  } else {
    config = options;
  }

  // throw away the substring index information and just concatenate all the kana
  return splitIntoConvertedKana(input, config, map).map(kanaToken => {
    const [start, end, kana] = kanaToken;
    if (kana === null) {
      // haven't converted the end of the string, since we are in IME mode
      return input.slice(start);
    }
    const enforceHiragana = config.IMEMode === TO_KANA_METHODS.HIRAGANA;
    const enforceKatakana = config.IMEMode === TO_KANA_METHODS.KATAKANA || [...input.slice(start, end)].every(isCharUpperCase);

    return enforceHiragana || !enforceKatakana ? kana : hiraganaToKatakana(kana);
  }).join('');
}

/**
 *
 * @private
 * @param {String} [input=''] input text
 * @param {Object} [options={}] toKana options
 * @returns {Array[]} [[start, end, token]]
 * @example
 * splitIntoConvertedKana('buttsuuji')
 * // => [[0, 2, 'ã¶'], [2, 6, 'ã£ã¤'], [6, 7, 'ã†'], [7, 9, 'ã˜']]
 */
function splitIntoConvertedKana(input = '', options = {}, map) {
  if (!map) {
    map = createRomajiToKanaMap$1(options);
  }
  return applyMapping(input.toLowerCase(), map, !options.IMEMode);
}

let customMapping = null;
function createRomajiToKanaMap$1(options = {}) {
  let map = getRomajiToKanaTree();

  map = options.IMEMode ? IME_MODE_MAP(map) : map;
  map = options.useObsoleteKana ? USE_OBSOLETE_KANA_MAP(map) : map;

  if (options.customKanaMapping) {
    if (customMapping == null) {
      customMapping = mergeCustomMapping(map, options.customKanaMapping);
    }
    map = customMapping;
  }

  return map;
}

let LISTENERS = [];
/**
 * Automagically replaces input values with converted text to kana
 * @param  {defaultOptions} [options] user config overrides, default conversion is toKana()
 * @return {Function} event handler with bound options
 * @private
 */
function makeOnInput(options) {
  let prevInput;
  // Enforce IMEMode if not already specified
  const mergedConfig = Object.assign({}, mergeWithDefaultOptions(options), {
    IMEMode: options.IMEMode || true
  });
  const preConfiguredMap = createRomajiToKanaMap$1(mergedConfig);
  const triggers = [...Object.keys(preConfiguredMap), ...Object.keys(preConfiguredMap).map(char => char.toUpperCase())];

  return function onInput({ target }) {
    if (target.value !== prevInput && target.dataset.ignoreComposition !== 'true') {
      convertInput(target, mergedConfig, preConfiguredMap, triggers, prevInput);
    }
  };
}

function convertInput(target, options, map, triggers, prevInput) {
  const [head, textToConvert, tail] = splitInput(target.value, target.selectionEnd, triggers);
  const convertedText = toKana(textToConvert, options, map);
  const changed = textToConvert !== convertedText;

  if (changed) {
    const newCursor = head.length + convertedText.length;
    const newValue = head + convertedText + tail;
    target.value = newValue;
    prevInput = newValue;

    if (tail.length) {
      // push later on event loop (otherwise mid-text insertion can be 1 char too far to the right)
      setTimeout(() => target.setSelectionRange(newCursor, newCursor), 1);
    } else {
      target.setSelectionRange(newCursor, newCursor);
    }
  } else {
    prevInput = target.value;
  }
}

function onComposition({ type, target, data }) {
  // navigator.platform is not 100% reliable for singling out all OS,
  // but for determining desktop "Mac OS" it is effective enough.
  const isMacOS = /Mac/.test(window.navigator && window.navigator.platform);
  // We don't want to ignore on Android:
  // https://github.com/WaniKani/WanaKana/issues/82
  // But MacOS IME auto-closes if we don't ignore:
  // https://github.com/WaniKani/WanaKana/issues/71
  // Other platform Japanese IMEs pass through happily
  if (isMacOS) {
    if (type === 'compositionupdate' && isJapanese(data)) {
      target.dataset.ignoreComposition = 'true';
    }

    if (type === 'compositionend') {
      target.dataset.ignoreComposition = 'false';
    }
  }
}

function trackListeners(id, inputHandler, compositionHandler) {
  LISTENERS = LISTENERS.concat({
    id,
    inputHandler,
    compositionHandler
  });
}

function untrackListeners({ id: targetId }) {
  LISTENERS = LISTENERS.filter(({ id }) => id !== targetId);
}

function findListeners(el) {
  return el && LISTENERS.find(({ id }) => id === el.getAttribute('data-wanakana-id'));
}

// Handle non-terminal inserted input conversion:
// | -> ã‚| -> ã‚ã³| -> ã‚|ã³ -> ã‚s|ã³ -> ã‚sh|ã³ -> ã‚shi|ã³ -> ã‚ã—|ã³
// or multiple ambiguous positioning (to select which "s" to work from)
// ã“sã“s|ã“sã“ -> ã“sã“so|ã“sã“ -> ã“sã“ã|ã“sã“
function splitInput(text = '', cursor = 0, triggers = []) {
  let head;
  let toConvert;
  let tail;

  if (cursor === 0 && triggers.includes(text[0])) {
    [head, toConvert, tail] = workFromStart(text, triggers);
  } else if (cursor > 0) {
    [head, toConvert, tail] = workBackwards(text, cursor);
  } else {
    [head, toConvert] = takeWhileAndSlice(text, char => !triggers.includes(char));
    [toConvert, tail] = takeWhileAndSlice(toConvert, char => !isJapanese(char));
  }

  return [head, toConvert, tail];
}

function workFromStart(text, catalystChars) {
  return ['', ...takeWhileAndSlice(text, char => catalystChars.includes(char) || !isJapanese(char, /[0-9]/))];
}

function workBackwards(text = '', startIndex = 0) {
  const [toConvert, head] = takeWhileAndSlice([...text.slice(0, startIndex)].reverse(), char => !isJapanese(char));
  return [head.reverse().join(''), toConvert.split('').reverse().join(''), text.slice(startIndex)];
}

function takeWhileAndSlice(source = {}, predicate = x => !!x) {
  const result = [];
  const { length } = source;
  let i = 0;
  while (i < length && predicate(source[i], i)) {
    result.push(source[i]);
    i += 1;
  }
  return [result.join(''), source.slice(i)];
}

/* eslint-disable no-console */
const onInput = ({ target: { value, selectionStart, selectionEnd } }) => console.log('input:', { value, selectionStart, selectionEnd });
const onCompositionStart = () => console.log('compositionstart');
const onCompositionUpdate = ({ target: { value, selectionStart, selectionEnd }, data }) => console.log('compositionupdate', {
  data,
  value,
  selectionStart,
  selectionEnd
});
const onCompositionEnd = () => console.log('compositionend');

const events = {
  input: onInput,
  compositionstart: onCompositionStart,
  compositionupdate: onCompositionUpdate,
  compositionend: onCompositionEnd
};

const addDebugListeners = input => {
  Object.entries(events).forEach(([event, handler]) => input.addEventListener(event, handler));
};

const removeDebugListeners = input => {
  Object.entries(events).forEach(([event, handler]) => input.removeEventListener(event, handler));
};

const ELEMENTS = ['TEXTAREA', 'INPUT'];

let idCounter = 0;
const newId = () => {
  idCounter += 1;
  return `${Date.now()}${idCounter}`;
};

/**
 * Binds eventListener for 'input' events to an input field to automagically replace values with kana
 * Can pass `{ IMEMode: 'toHiragana' || 'toKatakana' }` to enforce kana conversion type
 * @param  {HTMLElement} element textarea, input[type="text"] etc
 * @param  {DefaultOptions} [options=defaultOptions] defaults to { IMEMode: true } using `toKana`
 * @example
 * bind(document.querySelector('#myInput'));
 */
function bind(element = {}, options = {}, debug = false) {
  if (!ELEMENTS.includes(element.nodeName)) {
    throw new Error(`Element provided to Wanakana bind() was not a valid input or textarea element.\n Received: (${JSON.stringify(element)})`);
  }
  const onInput = makeOnInput(options);
  const id = newId();
  element.setAttribute('data-wanakana-id', id);
  element.setAttribute('lang', 'ja');
  element.setAttribute('autoCapitalize', 'none');
  element.setAttribute('autoCorrect', 'off');
  element.setAttribute('autoComplete', 'off');
  element.setAttribute('spellCheck', 'false');
  element.addEventListener('input', onInput);
  element.addEventListener('compositionupdate', onComposition);
  element.addEventListener('compositionend', onComposition);
  trackListeners(id, onInput, onComposition);
  if (debug === true) {
    addDebugListeners(element);
  }
}

/**
 * Unbinds eventListener from input field
 * @param  {HTMLElement} element textarea, input
 */
function unbind(element, debug = false) {
  const listeners = findListeners(element);
  if (listeners == null) {
    throw new Error(`Element provided to Wanakana unbind() had no listener registered.\n Received: ${JSON.stringify(element)}`);
  }
  const { inputHandler, compositionHandler } = listeners;
  element.removeAttribute('data-wanakana-id');
  element.removeAttribute('data-ignore-composition');
  element.removeEventListener('input', inputHandler);
  element.removeEventListener('compositionstart', compositionHandler);
  element.removeEventListener('compositionupdate', compositionHandler);
  element.removeEventListener('compositionend', compositionHandler);
  untrackListeners(listeners);
  if (debug === true) {
    removeDebugListeners(element);
  }
}

/**
 * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharRomaji(char = '') {
  if (isEmpty(char)) return false;
  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Test if `input` is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))
 * @param  {String} [input=''] text
 * @param  {Regexp} [allowed] additional test allowed to pass for each char
 * @return {Boolean} true if [Romaji](https://en.wikipedia.org/wiki/Romaji)
 * @example
 * isRomaji('TÅkyÅ and ÅŒsaka')
 * // => true
 * isRomaji('12a*b&c-d')
 * // => true
 * isRomaji('ã‚ã‚¢A')
 * // => false
 * isRomaji('ãŠé¡˜ã„')
 * // => false
 * isRomaji('aï¼b&cãƒ¼d') // Zenkaku punctuation fails
 * // => false
 * isRomaji('aï¼b&cãƒ¼d', /[ï¼ãƒ¼]/)
 * // => true
 */
function isRomaji(input = '', allowed) {
  const augmented = typeOf(allowed) === 'regexp';
  return isEmpty(input) ? false : [...input].every(char => {
    const isRoma = isCharRomaji(char);
    return !augmented ? isRoma : isRoma || allowed.test(char);
  });
}

/**
 * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKatakana(char = '') {
  return isCharInRange(char, KATAKANA_START, KATAKANA_END);
}

/**
 * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKana(char = '') {
  if (isEmpty(char)) return false;
  return isCharHiragana(char) || isCharKatakana(char);
}

/**
 * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)
 * @example
 * isKana('ã‚')
 * // => true
 * isKana('ã‚¢')
 * // => true
 * isKana('ã‚ãƒ¼ã‚¢')
 * // => true
 * isKana('A')
 * // => false
 * isKana('ã‚Aã‚¢')
 * // => false
 */
function isKana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKana);
}

/**
 * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)
 * @example
 * isHiragana('ã’ãƒ¼ã‚€')
 * // => true
 * isHiragana('A')
 * // => false
 * isHiragana('ã‚ã‚¢')
 * // => false
 */
function isHiragana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharHiragana);
}

/**
 * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @example
 * isKatakana('ã‚²ãƒ¼ãƒ ')
 * // => true
 * isKatakana('ã‚')
 * // => false
 * isKatakana('A')
 * // => false
 * isKatakana('ã‚ã‚¢')
 * // => false
 */
function isKatakana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKatakana);
}

/**
 * Tests a character. Returns true if the character is a CJK ideograph (kanji).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKanji(char = '') {
  return isCharInRange(char, KANJI_START, KANJI_END);
}

/**
 * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)
 * @example
 * isKanji('åˆ€')
 * // => true
 * isKanji('åˆ‡è…¹')
 * // => true
 * isKanji('å‹¢ã„')
 * // => false
 * isKanji('ã‚Aã‚¢')
 * // => false
 * isKanji('ğŸ¸')
 * // => false
 */
function isKanji(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKanji);
}

/**
 * Test if `input` contains a mix of [Romaji](https://en.wikipedia.org/wiki/Romaji) *and* [Kana](https://en.wikipedia.org/wiki/Kana), defaults to pass through [Kanji](https://en.wikipedia.org/wiki/Kanji)
 * @param  {String} input text
 * @param  {Object} [options={ passKanji: true }] optional config to pass through kanji
 * @return {Boolean} true if mixed
 * @example
 * isMixed('Abã‚ã‚¢'))
 * // => true
 * isMixed('ãŠè…¹A')) // ignores kanji by default
 * // => true
 * isMixed('ãŠè…¹A', { passKanji: false }))
 * // => false
 * isMixed('ab'))
 * // => false
 * isMixed('ã‚ã‚¢'))
 * // => false
 */
function isMixed(input = '', options = { passKanji: true }) {
  const chars = [...input];
  let hasKanji = false;
  if (!options.passKanji) {
    hasKanji = chars.some(isKanji);
  }
  return (chars.some(isHiragana) || chars.some(isKatakana)) && chars.some(isRomaji) && !hasKanji;
}

const isCharInitialLongDash = (char, index) => isCharLongDash(char) && index < 1;
const isCharInnerLongDash = (char, index) => isCharLongDash(char) && index > 0;
const isKanaAsSymbol = char => ['ãƒ¶', 'ãƒµ'].includes(char);
const LONG_VOWELS = {
  a: 'ã‚',
  i: 'ã„',
  u: 'ã†',
  e: 'ãˆ',
  o: 'ã†'
};

// inject toRomaji to avoid circular dependency between toRomaji <-> katakanaToHiragana
function katakanaToHiragana(input = '', toRomaji, isDestinationRomaji) {
  let previousKana = '';

  return input.split('').reduce((hira, char, index) => {
    // Short circuit to avoid incorrect codeshift for 'ãƒ¼' and 'ãƒ»'
    if (isCharSlashDot(char) || isCharInitialLongDash(char, index) || isKanaAsSymbol(char)) {
      return hira.concat(char);
      // Transform long vowels: 'ã‚ªãƒ¼' to 'ãŠã†'
    } else if (previousKana && isCharInnerLongDash(char, index)) {
      // Transform previousKana back to romaji, and slice off the vowel
      const romaji = toRomaji(previousKana).slice(-1);
      // However, ensure 'ã‚ªãƒ¼' => 'ãŠãŠ' => 'oo' if this is a transform on the way to romaji
      if (isCharKatakana(input[index - 1]) && romaji === 'o' && isDestinationRomaji) {
        return hira.concat('ãŠ');
      }
      return hira.concat(LONG_VOWELS[romaji]);
    } else if (!isCharLongDash(char) && isCharKatakana(char)) {
      // Shift charcode.
      const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);
      const hiraChar = String.fromCharCode(code);
      previousKana = hiraChar;
      return hira.concat(hiraChar);
    }
    // Pass non katakana chars through
    previousKana = '';
    return hira.concat(char);
  }, []).join('');
}

let kanaToHepburnMap = null;

/* eslint-disable */
// prettier-ignore
const BASIC_ROMAJI = {
  ã‚: 'a', ã„: 'i', ã†: 'u', ãˆ: 'e', ãŠ: 'o',
  ã‹: 'ka', ã: 'ki', ã: 'ku', ã‘: 'ke', ã“: 'ko',
  ã•: 'sa', ã—: 'shi', ã™: 'su', ã›: 'se', ã: 'so',
  ãŸ: 'ta', ã¡: 'chi', ã¤: 'tsu', ã¦: 'te', ã¨: 'to',
  ãª: 'na', ã«: 'ni', ã¬: 'nu', ã­: 'ne', ã®: 'no',
  ã¯: 'ha', ã²: 'hi', ãµ: 'fu', ã¸: 'he', ã»: 'ho',
  ã¾: 'ma', ã¿: 'mi', ã‚€: 'mu', ã‚: 'me', ã‚‚: 'mo',
  ã‚‰: 'ra', ã‚Š: 'ri', ã‚‹: 'ru', ã‚Œ: 're', ã‚: 'ro',
  ã‚„: 'ya', ã‚†: 'yu', ã‚ˆ: 'yo',
  ã‚: 'wa', ã‚: 'wi', ã‚‘: 'we', ã‚’: 'wo',
  ã‚“: 'n',
  ãŒ: 'ga', ã: 'gi', ã: 'gu', ã’: 'ge', ã”: 'go',
  ã–: 'za', ã˜: 'ji', ãš: 'zu', ãœ: 'ze', ã: 'zo',
  ã : 'da', ã¢: 'ji', ã¥: 'zu', ã§: 'de', ã©: 'do',
  ã°: 'ba', ã³: 'bi', ã¶: 'bu', ã¹: 'be', ã¼: 'bo',
  ã±: 'pa', ã´: 'pi', ã·: 'pu', ãº: 'pe', ã½: 'po',
  ã‚”ã: 'va', ã‚”ãƒ: 'vi', ã‚”: 'vu', ã‚”ã‡: 've', ã‚”ã‰: 'vo'
};
/* eslint-enable  */

const SPECIAL_SYMBOLS$1 = {
  'ã€‚': '.',
  'ã€': ',',
  'ï¼š': ':',
  'ãƒ»': '/',
  'ï¼': '!',
  'ï¼Ÿ': '?',
  'ã€œ': '~',
  'ãƒ¼': '-',
  'ã€Œ': 'â€˜',
  'ã€': 'â€™',
  'ã€': 'â€œ',
  'ã€': 'â€',
  'ï¼»': '[',
  'ï¼½': ']',
  'ï¼ˆ': '(',
  'ï¼‰': ')',
  'ï½›': '{',
  'ï½': '}',
  'ã€€': ' '
};

// ã‚“ã„ -> n'i
const AMBIGUOUS_VOWELS = ['ã‚', 'ã„', 'ã†', 'ãˆ', 'ãŠ', 'ã‚„', 'ã‚†', 'ã‚ˆ'];
const SMALL_Y$1 = { ã‚ƒ: 'ya', ã‚…: 'yu', ã‚‡: 'yo' };
const SMALL_Y_EXTRA = { ãƒ: 'yi', ã‡: 'ye' };
const SMALL_AIUEO = {
  ã: 'a',
  ãƒ: 'i',
  ã…: 'u',
  ã‡: 'e',
  ã‰: 'o'
};
const YOON_KANA = ['ã', 'ã«', 'ã²', 'ã¿', 'ã‚Š', 'ã', 'ã³', 'ã´', 'ã‚”', 'ã', 'ãµ'];
const YOON_EXCEPTIONS = {
  ã—: 'sh',
  ã¡: 'ch',
  ã˜: 'j',
  ã¢: 'j'
};
const SMALL_KANA = {
  ã£: '',
  ã‚ƒ: 'ya',
  ã‚…: 'yu',
  ã‚‡: 'yo',
  ã: 'a',
  ãƒ: 'i',
  ã…: 'u',
  ã‡: 'e',
  ã‰: 'o'
};

// going with the intuitive (yet incorrect) solution where ã£ã‚„ -> yya and ã£ãƒ -> ii
// in other words, just assume the sokuon could have been applied to anything
const SOKUON_WHITELIST = {
  b: 'b',
  c: 't',
  d: 'd',
  f: 'f',
  g: 'g',
  h: 'h',
  j: 'j',
  k: 'k',
  m: 'm',
  p: 'p',
  q: 'q',
  r: 'r',
  s: 's',
  t: 't',
  v: 'v',
  w: 'w',
  x: 'x',
  z: 'z'
};

function getKanaToHepburnTree() {
  if (kanaToHepburnMap == null) {
    kanaToHepburnMap = createKanaToHepburnMap();
  }
  return kanaToHepburnMap;
}

function getKanaToRomajiTree(fullOptions) {
  switch (fullOptions.romanization) {
    case ROMANIZATIONS.HEPBURN:
      return getKanaToHepburnTree(fullOptions);
    default:
      return {};
  }
}

function createKanaToHepburnMap() {
  const romajiTree = transform(BASIC_ROMAJI);

  const subtreeOf = string => getSubTreeOf(romajiTree, string);
  const setTrans = (string, transliteration) => {
    subtreeOf(string)[''] = transliteration;
  };

  Object.entries(SPECIAL_SYMBOLS$1).forEach(([jsymbol, symbol]) => {
    subtreeOf(jsymbol)[''] = symbol;
  });

  [...Object.entries(SMALL_Y$1), ...Object.entries(SMALL_AIUEO)].forEach(([roma, kana]) => {
    setTrans(roma, kana);
  });

  // ãã‚ƒ -> kya
  YOON_KANA.forEach(kana => {
    const firstRomajiChar = subtreeOf(kana)[''][0];
    Object.entries(SMALL_Y$1).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, firstRomajiChar + yRoma);
    });
    // ããƒ -> kyi
    Object.entries(SMALL_Y_EXTRA).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, firstRomajiChar + yRoma);
    });
  });

  Object.entries(YOON_EXCEPTIONS).forEach(([kana, roma]) => {
    // ã˜ã‚ƒ -> ja
    Object.entries(SMALL_Y$1).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, roma + yRoma[1]);
    });
    // ã˜ãƒ -> jyi, ã˜ã‡ -> je
    setTrans(`${kana}ãƒ`, `${roma}yi`);
    setTrans(`${kana}ã‡`, `${roma}e`);
  });

  romajiTree['ã£'] = resolveTsu(romajiTree);

  Object.entries(SMALL_KANA).forEach(([kana, roma]) => {
    setTrans(kana, roma);
  });

  AMBIGUOUS_VOWELS.forEach(kana => {
    setTrans(`ã‚“${kana}`, `n'${subtreeOf(kana)['']}`);
  });

  // NOTE: could be re-enabled with an option?
  // // ã‚“ã° -> mbo
  // const LABIAL = [
  //   'ã°', 'ã³', 'ã¶', 'ã¹', 'ã¼',
  //   'ã±', 'ã´', 'ã·', 'ãº', 'ã½',
  //   'ã¾', 'ã¿', 'ã‚€', 'ã‚', 'ã‚‚',
  // ];
  // LABIAL.forEach((kana) => {
  //   setTrans(`ã‚“${kana}`, `m${subtreeOf(kana)['']}`);
  // });

  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));
}

function resolveTsu(tree) {
  return Object.entries(tree).reduce((tsuTree, [key, value]) => {
    if (!key) {
      // we have reached the bottom of this branch
      const consonant = value.charAt(0);
      tsuTree[key] = Object.keys(SOKUON_WHITELIST).includes(consonant) ? SOKUON_WHITELIST[consonant] + value : value;
    } else {
      // more subtrees
      tsuTree[key] = resolveTsu(value);
    }
    return tsuTree;
  }, {});
}

/**
 * Convert kana to romaji
 * @param  {String} kana text input
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toRomaji('ã²ã‚‰ãŒãªã€€ã‚«ã‚¿ã‚«ãƒŠ')
 * // => 'hiragana katakana'
 * toRomaji('ã’ãƒ¼ã‚€ã€€ã‚²ãƒ¼ãƒ ')
 * // => 'ge-mu geemu'
 * toRomaji('ã²ã‚‰ãŒãªã€€ã‚«ã‚¿ã‚«ãƒŠ', { upcaseKatakana: true })
 * // => 'hiragana KATAKANA'
 * toRomaji('ã¤ã˜ãã‚Š', { customRomajiMapping: { ã˜: 'zi', ã¤: 'tu', ã‚Š: 'li' } });
 * // => 'tuzigili'
 */
function toRomaji(input = '', options = {}) {
  const mergedOptions = mergeWithDefaultOptions(options);
  // just throw away the substring index information and just concatenate all the kana
  return splitIntoRomaji(input, mergedOptions).map(romajiToken => {
    const [start, end, romaji] = romajiToken;
    const makeUpperCase = options.upcaseKatakana && isKatakana(input.slice(start, end));
    return makeUpperCase ? romaji.toUpperCase() : romaji;
  }).join('');
}

let customMapping$1 = null;
function splitIntoRomaji(input, options) {
  let map = getKanaToRomajiTree(options);

  if (options.customRomajiMapping) {
    if (customMapping$1 == null) {
      customMapping$1 = mergeCustomMapping(map, options.customRomajiMapping);
    }
    map = customMapping$1;
  }

  return applyMapping(katakanaToHiragana(input, toRomaji, true), map, !options.IMEMode);
}

/**
 * Tests a character. Returns true if the character is considered English punctuation.
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharEnglishPunctuation(char = '') {
  if (isEmpty(char)) return false;
  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Convert input to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)
 * @param  {String} [input=''] text
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toHiragana('toukyou, ã‚ªã‚ªã‚µã‚«')
 * // => 'ã¨ã†ãã‚‡ã†ã€ã€€ãŠãŠã•ã‹'
 * toHiragana('only ã‚«ãƒŠ', { passRomaji: true })
 * // => 'only ã‹ãª'
 * toHiragana('wi')
 * // => 'ã†ãƒ'
 * toHiragana('wi', { useObsoleteKana: true })
 * // => 'ã‚'
 */
function toHiragana(input = '', options = {}) {
  const config = mergeWithDefaultOptions(options);
  if (config.passRomaji) {
    return katakanaToHiragana(input, toRomaji);
  }

  if (isMixed(input, { passKanji: true })) {
    const convertedKatakana = katakanaToHiragana(input, toRomaji);
    return toKana(convertedKatakana.toLowerCase(), config);
  }

  if (isRomaji(input) || isCharEnglishPunctuation(input)) {
    return toKana(input.toLowerCase(), config);
  }

  return katakanaToHiragana(input, toRomaji);
}

/**
 * Convert input to [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @param  {String} [input=''] text
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toKatakana('toukyou, ãŠãŠã•ã‹')
 * // => 'ãƒˆã‚¦ã‚­ãƒ§ã‚¦ã€ã€€ã‚ªã‚ªã‚µã‚«'
 * toKatakana('only ã‹ãª', { passRomaji: true })
 * // => 'only ã‚«ãƒŠ'
 * toKatakana('wi')
 * // => 'ã‚¦ã‚£'
 * toKatakana('wi', { useObsoleteKana: true })
 * // => 'ãƒ°'
 */
function toKatakana(input = '', options = {}) {
  const mergedOptions = mergeWithDefaultOptions(options);
  if (mergedOptions.passRomaji) {
    return hiraganaToKatakana(input);
  }

  if (isMixed(input) || isRomaji(input) || isCharEnglishPunctuation(input)) {
    const hiragana = toKana(input.toLowerCase(), mergedOptions);
    return hiraganaToKatakana(hiragana);
  }

  return hiraganaToKatakana(input);
}

/**
 * Tests a character. Returns true if the character is considered English punctuation.
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharJapanesePunctuation(char = '') {
  if (isEmpty(char)) return false;
  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

const isCharEnSpace = x => x === ' ';
const isCharJaSpace = x => x === 'ã€€';
const isCharJaNum = x => /[ï¼-ï¼™]/.test(x);
const isCharEnNum = x => /[0-9]/.test(x);

const TOKEN_TYPES = {
  EN: 'en',
  JA: 'ja',
  EN_NUM: 'englishNumeral',
  JA_NUM: 'japaneseNumeral',
  EN_PUNC: 'englishPunctuation',
  JA_PUNC: 'japanesePunctuation',
  KANJI: 'kanji',
  HIRAGANA: 'hiragana',
  KATAKANA: 'katakana',
  SPACE: 'space',
  OTHER: 'other'
};

// prettier-ignore
function getType(input, compact = false) {
  const {
    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER
  } = TOKEN_TYPES;

  if (compact) {
    switch (true) {
      case isCharJaNum(input):
        return OTHER;
      case isCharEnNum(input):
        return OTHER;
      case isCharEnSpace(input):
        return EN;
      case isCharEnglishPunctuation(input):
        return OTHER;
      case isCharJaSpace(input):
        return JA;
      case isCharJapanesePunctuation(input):
        return OTHER;
      case isCharJapanese(input):
        return JA;
      case isCharRomaji(input):
        return EN;
      default:
        return OTHER;
    }
  } else {
    switch (true) {
      case isCharJaSpace(input):
        return SPACE;
      case isCharEnSpace(input):
        return SPACE;
      case isCharJaNum(input):
        return JA_NUM;
      case isCharEnNum(input):
        return EN_NUM;
      case isCharEnglishPunctuation(input):
        return EN_PUNC;
      case isCharJapanesePunctuation(input):
        return JA_PUNC;
      case isCharKanji(input):
        return KANJI;
      case isCharHiragana(input):
        return HIRAGANA;
      case isCharKatakana(input):
        return KATAKANA;
      case isCharJapanese(input):
        return JA;
      case isCharRomaji(input):
        return EN;
      default:
        return OTHER;
    }
  }
}

/**
 * Splits input into array of strings separated by opinionated token types
 * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.
 * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).
 * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`
 * @param  {String} input text
 * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style
 * @return {String|Object[]} text split into tokens containing values, or detailed object
 * @example
 * tokenize('ãµãµãƒ•ãƒ•')
 * // ['ãµãµ', 'ãƒ•ãƒ•']
 *
 * tokenize('æ„Ÿã˜')
 * // ['æ„Ÿ', 'ã˜']
 *
 * tokenize('truly ç§ã¯æ‚²ã—ã„')
 * // ['truly', ' ', 'ç§', 'ã¯', 'æ‚²', 'ã—ã„']
 *
 * tokenize('truly ç§ã¯æ‚²ã—ã„', { compact: true })
 * // ['truly ', 'ç§ã¯æ‚²ã—ã„']
 *
 * tokenize('5romaji here...!?æ¼¢å­—ã²ã‚‰ãŒãªï¼”ã‚«ã‚¿ã€€ã‚«ãƒŠã€Œï¼³ï¼¨ï¼©ï¼¯ã€ã€‚ï¼')
 * // [ '5', 'romaji', ' ', 'here', '...!?', 'æ¼¢å­—', 'ã²ã‚‰ãŒãª', 'ã‚«ã‚¿', 'ã€€', 'ã‚«ãƒŠ', 'ï¼”', 'ã€Œ', 'ï¼³ï¼¨ï¼©ï¼¯', 'ã€ã€‚ï¼']
 *
 * tokenize('5romaji here...!?æ¼¢å­—ã²ã‚‰ãŒãªï¼”ã‚«ã‚¿ã€€ã‚«ãƒŠã€Œï¼³ï¼¨ï¼©ï¼¯ã€ã€‚ï¼', { compact: true })
 * // [ '5', 'romaji here', '...!?', 'æ¼¢å­—ã²ã‚‰ãŒãªã‚«ã‚¿ã€€ã‚«ãƒŠ', 'ï¼”ã€Œ', 'ï¼³ï¼¨ï¼©ï¼¯', 'ã€ã€‚ï¼']
 *
 * tokenize('5romaji here...!?æ¼¢å­—ã²ã‚‰ãŒãªã‚«ã‚¿ã€€ã‚«ãƒŠï¼”ã€Œï¼³ï¼¨ï¼©ï¼¯ã€ã€‚ï¼ Ù„Ù†Ø°Ù‡Ø¨', { detailed: true })
 * // [
 *  { type: 'englishNumeral', value: '5' },
 *  { type: 'en', value: 'romaji' },
 *  { type: 'space', value: ' ' },
 *  { type: 'en', value: 'here' },
 *  { type: 'englishPunctuation', value: '...!?' },
 *  { type: 'kanji', value: 'æ¼¢å­—' },
 *  { type: 'hiragana', value: 'ã²ã‚‰ãŒãª' },
 *  { type: 'katakana', value: 'ã‚«ã‚¿' },
 *  { type: 'space', value: 'ã€€' },
 *  { type: 'katakana', value: 'ã‚«ãƒŠ' },
 *  { type: 'japaneseNumeral', value: 'ï¼”' },
 *  { type: 'japanesePunctuation', value: 'ã€Œ' },
 *  { type: 'ja', value: 'ï¼³ï¼¨ï¼©ï¼¯' },
 *  { type: 'japanesePunctuation', value: 'ã€ã€‚ï¼' },
 *  { type: 'space', value: ' ' },
 *  { type: 'other', value: 'Ù„Ù†Ø°Ù‡Ø¨' },
 * ]
 *
 * tokenize('5romaji here...!?æ¼¢å­—ã²ã‚‰ãŒãªã‚«ã‚¿ã€€ã‚«ãƒŠï¼”ã€Œï¼³ï¼¨ï¼©ï¼¯ã€ã€‚ï¼ Ù„Ù†Ø°Ù‡Ø¨', { compact: true, detailed: true})
 * // [
 *  { type: 'other', value: '5' },
 *  { type: 'en', value: 'romaji here' },
 *  { type: 'other', value: '...!?' },
 *  { type: 'ja', value: 'æ¼¢å­—ã²ã‚‰ãŒãªã‚«ã‚¿ã€€ã‚«ãƒŠ' },
 *  { type: 'other', value: 'ï¼”ã€Œ' },
 *  { type: 'ja', value: 'ï¼³ï¼¨ï¼©ï¼¯' },
 *  { type: 'other', value: 'ã€ã€‚ï¼' },
 *  { type: 'en', value: ' ' },
 *  { type: 'other', value: 'Ù„Ù†Ø°Ù‡Ø¨' },
 *]
 */
function tokenize(input, { compact = false, detailed = false } = {}) {
  if (input == null || isEmpty(input)) {
    return [];
  }
  const chars = [...input];
  let initial = chars.shift();
  let prevType = getType(initial, compact);
  initial = detailed ? { type: prevType, value: initial } : initial;

  const result = chars.reduce((tokens, char) => {
    const currType = getType(char, compact);
    const sameType = currType === prevType;
    prevType = currType;
    let newValue = char;

    if (sameType) {
      newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;
    }

    return detailed ? tokens.concat({ type: currType, value: newValue }) : tokens.concat(newValue);
  }, [initial]);
  return result;
}

const isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);
const isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);
const isInvalidMatcher = (input, matchKanji) => matchKanji && ![...matchKanji].some(isKanji) || !matchKanji && isKana(input);

/**
 * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)
 * @param  {String} input text
 * @param  {Object} [options={ leading: false, matchKanji: '' }] optional config
 * @return {String} text with okurigana removed
 * @example
 * stripOkurigana('è¸ã¿è¾¼ã‚€')
 * // => 'è¸ã¿è¾¼'
 * stripOkurigana('ãŠç¥ã„')
 * // => 'ãŠç¥'
 * stripOkurigana('ãŠè…¹', { leading: true });
 * // => 'è…¹'
 * stripOkurigana('ãµã¿ã“ã‚€', { matchKanji: 'è¸ã¿è¾¼ã‚€' });
 * // => 'ãµã¿ã“'
 * stripOkurigana('ãŠã¿ã¾ã„', { matchKanji: 'ãŠç¥ã„', leading: true });
 * // => 'ã¿ã¾ã„'
 */
function stripOkurigana(input = '', { leading = false, matchKanji = '' } = {}) {
  if (!isJapanese(input) || isLeadingWithoutInitialKana(input, leading) || isTrailingWithoutFinalKana(input, leading) || isInvalidMatcher(input, matchKanji)) {
    return input;
  }

  const chars = matchKanji || input;
  const okuriganaRegex = new RegExp(leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`);
  return input.replace(okuriganaRegex, '');
}

exports.bind = bind;
exports.unbind = unbind;
exports.isRomaji = isRomaji;
exports.isJapanese = isJapanese;
exports.isKana = isKana;
exports.isHiragana = isHiragana;
exports.isKatakana = isKatakana;
exports.isMixed = isMixed;
exports.isKanji = isKanji;
exports.toRomaji = toRomaji;
exports.toKana = toKana;
exports.toHiragana = toHiragana;
exports.toKatakana = toKatakana;
exports.stripOkurigana = stripOkurigana;
exports.tokenize = tokenize;
exports.VERSION = VERSION;
exports.TO_KANA_METHODS = TO_KANA_METHODS;
exports.ROMANIZATIONS = ROMANIZATIONS;
